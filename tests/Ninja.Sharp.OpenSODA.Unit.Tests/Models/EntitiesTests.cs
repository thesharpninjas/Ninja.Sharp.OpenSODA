using System.Reflection;

namespace Ninja.Sharp.OpenSODA.Unit.Tests.Models
{
    public class EntitiesTest
    {
        [Theory]
        [InlineData("Ninja.Sharp.OpenSODA")]
        public void Exceptions_Construct_OK(string assemblyName)
        {
            Assembly assembly = Assembly.Load(assemblyName);
            List<Type> types = assembly
                .GetTypes()
                .Where(myType => myType.IsClass && !myType.IsAbstract && myType.IsSubclassOf(typeof(Exception)))
                .ToList();
            foreach (Type type in types)
            {
                Exception? c1 = (Exception?)Activator.CreateInstance(type);
                Exception? c2 = (Exception?)Activator.CreateInstance(type, "test");
                Exception? c3 = (Exception?)Activator.CreateInstance(type, "test", new Exception());

                Assert.NotNull(c1);
                Assert.NotNull(c2);
                Assert.NotNull(c3);
            }
            Assert.NotNull(types);
            Assert.NotEmpty(types);
        }

        [Theory]
        [InlineData("Ninja.Sharp.OpenSODA", "Ninja.Sharp.OpenSODA.Models")]
        public void Models_Construct_OK(string assemblyName, params string[] namespaces)
        {
            Assembly assembly = Assembly.Load(assemblyName);
            List<Type> types = assembly
                .GetTypes()
                .Where(t => namespaces.Contains(t.Namespace))
                .ToList();
            foreach (Type type in types.Where(x => !x.IsAbstract))
            {
                object? r;
                if (type.IsGenericType)
                {
                    Type constructedType = type.MakeGenericType(typeof(object));
                    r = Activator.CreateInstance(constructedType);
                }
                else
                {
                    r = Activator.CreateInstance(type);
                }
                PropertyInfo[] propertyInfo = r!.GetType().GetProperties();
                foreach (PropertyInfo property in propertyInfo)
                {
                    object? _value = property.GetValue(r);
                    Type _propertyType = property.PropertyType;
                    if (!_propertyType.IsAbstract && _value != null)
                    {
                        if (!_propertyType.IsValueType)
                        {
                            Assert.True(_value!.GetType().IsAssignableFrom(_propertyType));
                        }
                        else
                        {
                            Assert.NotNull(_value);
                        }
                    }
                }
            }
            Assert.NotNull(types);
            Assert.NotEmpty(types);
        }

        [Fact]
        public void AutoGeneratedProgramMain_Ok()
        {
            MethodInfo[] methods = typeof(AutoGeneratedProgram).GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);
            Exception? exception = Record.Exception(() => methods[0].Invoke(null, [Array.Empty<string>()]));
            Assert.Null(exception);
        }
    }
}
